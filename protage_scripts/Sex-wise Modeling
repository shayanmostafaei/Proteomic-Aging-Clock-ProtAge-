library(dplyr)
library(glmnet)
library(mlr3)
library(mlr3learners)
library(mlr3pipelines)
library(nnet)
library(xgboost)
library(caret)

set.seed(123)

# cleaned_protein_data includes columns: age, sex, protein features
data_for_ml <- cleaned_protein_data %>%
  # Ensure 'age' is numeric (target) and 'sex' is a factor (grouping variable)
  mutate(age = as.numeric(age), sex = as.factor(sex))

# --- Removed Age Group Definition ---

# Define groups: ONLY Sex (assuming sex is coded as 0 and 1, adjust if needed)
# If sex is coded as "male" and "female", change c(0, 1) to c("male", "female") or levels(data_for_ml$sex)
groups <- data.frame(sex = c(0, 1))

results <- list()
# Loop only through the sex groups
for (i in 1:nrow(groups)) {
  group <- groups[i, ]
  # Filter data only by sex
  group_train <- data_for_ml %>% filter(sex == group$sex)

  # Check if the group has enough data to train (optional, but good practice)
  if (nrow(group_train) > 0) {
    # Feature selection
    # Exclude 'age' (target) and 'sex' (grouping) from features
    x_train <- as.matrix(group_train %>% select(-age, -sex))
    y_train <- group_train$age

    # Elastic Net for feature selection
    enet_model <- cv.glmnet(x_train, y_train, alpha = 0.5)
    selected_features <- coef(enet_model, s = "lambda.min") %>%
      as.matrix() %>%
      rownames() %>%
      .[. != "(Intercept)"]

    if (length(selected_features) == 0) {
      message(paste("Skipping group", group$sex, "due to no selected features."))
      next
    }

    # Prepare data for mlr3 task with selected features
    group_train_mlr3 <- group_train %>% select(all_of(selected_features), age)

    # mlr3 Task definition
    task <- TaskRegr$new(id = paste0("age_prediction_sex_", group$sex),
                         backend = group_train_mlr3,
                         target = "age")

    # Define Learners
    learner_xgb <- lrn("regr.xgboost", nrounds=500, eta=0.03, max_depth=6)
    learner_rf <- lrn("regr.ranger", num.trees=1000, min.node.size=3)
    learner_nn <- lrn("regr.nnet", size=5, linout=TRUE, maxit=200, trace=FALSE) # Added trace=FALSE for cleaner output

    # Stacked Ensemble Pipeline
    stacked_pipeline <- gunion(list(
      po("learner_cv", learner_xgb),
      po("learner_cv", learner_rf),
      po("learner_cv", learner_nn)
    )) %>>% po("featureunion") %>>% po("learner", lrn("regr.glmnet"))

    stacked_learner <- as_learner(stacked_pipeline)

    # Train the model
    message(paste("Training model for Sex =", group$sex))
    stacked_learner$train(task)
    results[[paste("Sex", group$sex, sep = "_")]] <- stacked_learner

    # Predict on training data
    pred <- stacked_learner$predict(task)
    group_data <- group_train_mlr3
    group_data$predicted_age <- pred$response

    # Calculate Metrics
    correlation <- cor(group_data$age, group_data$predicted_age)
    r_squared <- correlation^2
    rmse <- sqrt(mean((group_data$age - group_data$predicted_age)^2))
    mae <- mean(abs(group_data$age - group_data$predicted_age))

    # Scatter plot for the group
    plot(group_data$age, group_data$predicted_age,
         xlab = "Actual Age",
         ylab = "Predicted Age (ProtAge)",
         main = paste("Group: Sex =", group$sex,
                      "\nCorrelation:", round(correlation, 2),
                      "| R-squared:", round(r_squared, 2),
                      "| MAE:", round(mae, 2),
                      "| RMSE:", round(rmse, 2)),
         pch = 19, col = "green", cex = 0.6)

    # Add a reference line (ideal case where predicted = actual)
    abline(0, 1, col = "red", lwd = 2)
  } else {
    message(paste("Skipping group Sex =", group$sex, "due to insufficient data."))
  }
}
